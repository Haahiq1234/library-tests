<html>
<body>
    <script src="Canvas.js"></script>
    <script>
        let walls = [];
        let particle;
        let padding = 30;
        let width = 400;
        let height = 400;
        let scene = [];
        function setUp() {
            particle = new Particle();
            createCanvas(800, 400, "black");
            frameRate(50);
            for (var i = 0; i < 5; i++) {
                walls.push(new boundary(Random.range(width), Random.range(height), Random.range(width), Random.range(height)));
            }
            walls.push(new boundary(-padding, -padding, width + padding, -padding));
            walls.push(new boundary(-padding, height + padding, width + padding, height + padding));
            walls.push(new boundary(width + padding, -padding, width + padding, height + padding));
            walls.push(new boundary(-padding, -padding, -padding, height + padding));
        }
        function draw() {
            clear();
            particle.rotate(GetAxis("horizontal", "arrow") * 2);
            particle.update();
            scene = particle.look(walls);
            push();
            translate(width + padding, 0);
            let w = (CanvasWidth - width - padding) / scene.length;
            for (let i = 0; i < scene.length; i++) {
                fill(map(scene[i], 0, width, 255, 0));
                noStroke();
                let h = map(scene[i], 0, width, height, 0);
                let y = (height - h) / 2;
                rect(i * w - 1, y, w + 1, h);
            }
            pop();
            for (let wall of walls) {
                wall.show();
            }
        }
        class Particle {
            constructor() {
                this.pos = createVector();
                this.rays = [];
                this.offsetAngle = 0;
                for (var i = 0; i < 45; i += 0.25) {
                    this.rays.push(new Ray(i));
                }
            }
            rotate(ang) {
                for (var i = 0; i < this.rays.length; i += 1) {
                    this.rays[i].b.rotate(ang);
                }
                this.offsetAngle += ang;
            }
            update() {
                let vel = Vector.AngleToVector(this.offsetAngle + this.rays.length / 8, GetAxis("vertical", "arrow") * 3);
                this.pos.add(vel.mult(-1));
                this.pos.x = constraint(this.pos.x, 0, width);
                this.pos.y = constraint(this.pos.y, 0, height);
            }
            look(walls) {
                let scene = [];
                for (var i = 0; i < this.rays.length; i++) {
                    this.rays[i].update(this.pos.copy());
                    let nPos;
                    let length = Infinity;
                    for (let wall of walls) {
                        let nPos1 = this.rays[i].cast(wall);
                        if (nPos1) {
                            let len = Vector.sub(nPos1, this.rays[i].a).mag();
                            if (len < length) {
                                nPos = nPos1;
                                length = len;
                            }
                        }
                    }
                    scene[i] = length;
                    this.rays[i].show(nPos);
                }
                return scene;
            }
        }
        class Ray {
            constructor(dir) {
                this.a = createVector();
                this.b = Vector.AngleToVector(dir, (width + height) * 2);
            }
            update(pos) {
                this.a = pos.copy();
            }
            show(b) {
                stroke(255);
                if (!b) {
                    b = Vector.add(this.a, this.b);
                }
                lineWidth(0.5);
                line(this.a.x, this.a.y, b.x, b.y);
            }
            cast(wall) {
                let x1 = wall.a.x;
                let y1 = wall.a.y;
                let x2 = wall.b.x;
                let y2 = wall.b.y;

                let x3 = this.a.x;
                let y3 = this.a.y;
                let x4 = this.a.x + this.b.x;
                let y4 = this.a.y + this.b.y;

                //let d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                //let u = ((x1 - x3) * (y1 - y2) - (y1 - y3) * (x1 - x2)) / d;
                //let t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / d;
                //if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                //    let x = x1 + t * (x2 - x1);
                //    let y = y1 + t * (y2 - y1);
                //    return createVector(x, y);
                //}

                let intersection = lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4);
                if (intersection.intersected) {
                    return intersection.point;
                }
            }
        }
        class boundary {
            constructor(x, y, x1, y1) {
                this.a = createVector(x, y);
                this.b = createVector(x1, y1);
            }
            show() {
                stroke(255);
                lineWidth(1);
                line(this.a.x, this.a.y, this.b.x, this.b.y);
            }
        }
    </script>

</body>
</html>
